{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                              Official SCAR Include
                                  Array Routines
--------------------------------------------------------------------------------
 * function InStrArrPos(S: string; Arr: TStringArray; var Pos: Integer; CaseSenstive: Boolean): Boolean;
     By: Wanted
 * function IntInTIAPos(Int: Integer; TIA: TIntegerArray; var Pos: Integer): Boolean;
     By: Wanted
 * procedure RemoveTPAFromATPA(var ATPA: T2DPointArray; Index: Integer);
     By: Wanted
 * function TBOutlineToTPA(TB: TBox): TPointArray;
     By: Wanted
 * function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
     By: Wanted
 * function LoadTextTPA(Text: string; Chars: Integer): TPointArray;
     By: Anonymous
 * function FindTextTPAInTPA(TextTPA, SearchTPA: TPointArray; var X, Y: LongInt): Boolean;
     By: Wanted
 * procedure SortATPASize(var ATPA: T2DPointArray; BigFirst: Boolean);
     By: Wanted
 * procedure FilterPointsDist(var Points: TPointArray; MinDist, MaxDist, CX, CY: Extended);
     By: Wanted
 * procedure FilterPointsPie(var Points: TPointArray; SRad, ERad, SAng, EAng: Extended; CX, CY: Integer);
     By: Wanted
 * function FindColorsCircleTolerance(var Points: TPointArray; Color, Tol: Integer; CX, CY, R: Extended): Boolean;
     By: Wanted
 * function PointsNotInTPA(TPA: TPointArray): TPointArray;
     By: Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function InStrArrPos(S: string; Arr: TStringArray; var Pos: Integer; CaseSenstive: Boolean): Boolean;
Contributors: Wanted
Description: Returns true if the string is in the array and returns position.
Date Created: October 10th, 2011. By Wanted
Last Modified: October 10th, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function InStrArrPos(S: string; Arr: TStringArray; var Pos: Integer; CaseSenstive: Boolean): Boolean;
var
  H, L: Integer;
  SS: string;
begin
  Result := True;
  H := High(Arr);
  L := Low(Arr);
  if (not (CaseSenstive)) then
  begin
    SS := LowerCase(S);
    for Pos := L to H do
      if (SS = LowerCase(Arr[Pos])) then
        Exit;
  end
  else
    for Pos := L to H do
      if (S = Arr[Pos]) then
        Exit;
  Result := False;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function IntInTIAPos(Int: Integer; TIA: TIntegerArray; var Pos: Integer): Boolean;
Contributors: Wanted
Description: Results true if Int is in the TIntegerArray and the Pos found.
Date Created: November 10th, 2011. By Wanted
Last Modified: November 10th, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function IntInTIAPos(Int: Integer; TIA: TIntegerArray; var Pos: Integer): Boolean;
var
  L, H: Integer;
begin
  Result := True;
  L := Low(TIA);
  H := High(TIA);
  for Pos := L to H do
    if (Int = TIA[Pos]) then
      Exit;
  Result := False;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure RemoveTPAFromATPA(var ATPA: T2DPointArray; Index: Integer);
Contributors: Wanted
Description: Removes a TPA by index from an ATPA.
Date Created: November 14th, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure RemoveTPAFromATPA(var ATPA: T2DPointArray; Index: Integer);
var
  NewATPA: T2DPointArray;
  I, H, II: Integer;
begin
  if (Length(ATPA) < 1) then
    Exit;
  H := High(ATPA);
  if (Index > H) then
    Exit;
  SetLength(NewATPA, Length(ATPA) - 1);
  II := 0;
  for I := 0 to H do
    if (not (I = Index)) then
    begin
      NewATPA[II] := ATPA[I];
      Inc(II);
    end;
  ATPA := NewATPA;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBOutlineToTPA(TB: TBox): TPointArray;
Contributors: Wanted
Description: Turns the outline of a TBox into a TPA.
Date Created: October 22nd, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBOutlineToTPA(TB: TBox): TPointArray;
var
  I, II, Hi, Lo: Integer;
begin
  Result := [];
  SetLength(Result, (((TB.X2 - TB.X1) * 2) + ((TB.Y2 - TB.Y1) * 2)));
  if (Length(Result) < 1) then
    Exit;
  II := 0;
  for I := TB.X1 to TB.X2 do
  begin
    Result[II] := Point(I, TB.Y1);
    Inc(II);
  end;
  Lo := TB.Y1 + 1;
  Hi := TB.Y2 - 1;
  for I := Lo to Hi do
  begin
    Result[II] := Point(TB.X2, I);
    Inc(II);
  end;
  if (TB.Y1 <> TB.Y2) then
    for I := TB.X2 downto TB.X1 do
    begin
      Result[II] := Point(I, TB.Y2);
      Inc(II);
    end;
  for I := Hi downto Lo do
  begin
    Result[II] := Point(TB.X1, I);
    Inc(II);
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
Contributors: Wanted
Description: Turns the outline of multiple TBoxes into multi TPAs.
Date Created: October 22nd, 2011. By Wanted
Last Modified: October 22nd, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
var
  I, H: LongInt;
begin
  H := High(TBA);
  SetLength(Result, H + 1);
  for I := 0 to H do
    Result[I] := TBOutlineToTPA(TBA[I]);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function LoadTextTPA(Text: string; Chars: Integer): TPointArray;
Contributors: Anonymous, Wanted.
Description: Turns a line of text into an array of points.
Date Created: August 7th, 2011. By Anonymous
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function LoadTextTPA(Text: string; Chars: Integer): TPointArray;
var
  CTS, W, H, bmpText: Integer;
  DC: HDC;
begin
  Result := [];
  if (Length(Text) < 1) then
    Exit;
  bmpText := CreateBitmapMaskFromText(Text, Chars);
  DC := GetClientCanvas.Handle;
  CTS := GetColorToleranceSpeed;
  GetBitmapSize(bmpText, W, H);
  ColorToleranceSpeed(0);
  SetTargetDC(GetBitmapDC(bmpText));
  FindColors(Result, clWhite, 0, 0, W + 1, H + 1);
  SetTargetDC(DC);
  ColorToleranceSpeed(CTS);
  FreeBitmap(bmpText);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function FindTextTPAInTPA(TextTPA, SearchTPA: TPointArray; var X, Y: LongInt): Boolean;
Contributors: Wanted, Freddy.
Description: Checks a TPA to see if contains the a line of text using its TPA.
Date Created: October 20th, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function FindTextTPAInTPA(Text: string; Chars: Integer; SearchTPA: TPointArray; var X, Y: LongInt): Boolean;
var
  TextTPA, TPA: TPointArray;
begin
  Result := False;
  TextTPA := LoadTextTPA(Text, Chars);
  if (not (TPAInTPARelEx(TextTPA, SearchTPA, TPA))) then
    Exit;
  X := TPA[0].X;
  Y := TPA[0].Y;
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure SortATPASize(var ATPA: T2DPointArray; BigFirst: Boolean);
Contributors: Wanted, Freddy.
Description: Sorts ATPAs based in their TPA lengths.
Date Created: October 22nd, 2011. By Wanted
Last Modified: October 23rd, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure SortATPASize(var ATPA: T2DPointArray; BigFirst: Boolean);
begin
  SortATPABySize(ATPA);
  if (BigFirst) then
    InvertATPA(ATPA);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure FilterPointsDist(var Points: TPointArray; MinDist, MaxDist, CX, CY: Extended);
Contributors: Wanted
Description: Removes all points not within distance.
Date Created: October 28th, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure FilterPointsDist(var Points: TPointArray; MinDist, MaxDist, CX, CY: Extended);
var
  H, L, I, HH: Integer;
  NewTPA: TPointArray;
  Dist: Extended;
begin
  H := High(Points);
  L := Low(Points);
  HH := 0;
  for I := L to H do
  begin
    Dist := DistanceEx(Points[I].X, Points[I].Y, CX, CY);
    if (Dist >= MinDist) then
      if (Dist <= MaxDist) then
      begin
        SetLength(NewTPA, HH + 1);
        NewTPA[HH] := Points[I];
        Inc(HH);
      end;
  end;
  Points := NewTPA;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure FilterPointsPie(var Points: TPointArray; SRad, ERad, SAng, EAng: Extended; CX, CY: Integer);
Contributors: Anonymous, Freddy, Wanted.
Description: Removes all points from a TPA except for a given slice.
Date Created: November 3rd, 2011. By Wanted
Last Modified: November 5th, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure FilterPointsPie(var Points: TPointArray; SRad, ERad, SAng, EAng: Extended; CX, CY: Integer);
var
  StartAngle, EndAngle, StartAngle2, EndAngle2: Extended;
  TPA, TPA2: TPointArray;
begin
  {$IFDEF RS2}
    StartAngle := SAng - 90;
    EndAngle := EAng - 90;
  {$ELSE}
    StartAngle := SAng;
    EndAngle := EAng;
  {$ENDIF}
  if (StartAngle < 0) then
  begin
    StartAngle2 := FixD(StartAngle);
    if (EndAngle < 0) then
    begin
      EndAngle2 := FixD(EndAngle);
      TPAExtractPie(Points, Point(CX, CY), SRad, ERad, Radians(StartAngle2), Radians(EndAngle2));
      Exit;
    end;
    StartAngle := 0;
    EndAngle2 := 360;
    TPA := Points;
    TPA2 := Points;
    TPAExtractPie(TPA, Point(CX, CY), SRad, ERad, Radians(StartAngle2), Radians(EndAngle2));
    TPAExtractPie(TPA2, Point(CX, CY), SRad, ERad, Radians(StartAngle), Radians(EndAngle));
    Points := CombineTPA(TPA, TPA2);
    Exit;
  end;
  TPAExtractPie(Points, Point(CX, CY), SRad, ERad, Radians(StartAngle), Radians(EndAngle));
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function FindColorsCircleTolerance(var Points: TPointArray; Color, Tol: Integer; CX, CY, R: Extended): Boolean;
Contributors: Wanted
Description: Finds colors within circle.
Date Created: October 28th, 2011. By Wanted
Last Modified: October 28th, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function FindColorsCircleTolerance(var Points: TPointArray; Color, Tol: Integer; CX, CY, R: Extended): Boolean;
begin
  FindColorsTolerance(Points, Color, Floor(CX - R), Floor(CY - R), Ceil(CX + R), Ceil(CY + R), Tol);
  FilterPointsDist(Points, 0, R, CX, CY);
  Result := (Length(Points) > 1);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function PointsNotInTPA(TPA: TPointArray): TPointArray;
Contributors: Wanted
Description: Finds empty points in TPA bounds.
Date Created: November 18th, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function PointsNotInTPA(TPA: TPointArray): TPointArray;
var
  TPA2: TPointArray;
  I, H, L, II: Integer;
  B: TBox;
begin
  Result := [];
  B := GetTPABounds(TPA);
  TPA2 := TPAFromBox(B);
  H := High(TPA2);
  L := Low(TPA2);
  II := 0;
  for I := L to H do
    if (not (TPAContains(TPA, TPA2[I]))) then
    begin
      Inc(II);
      SetLength(Result, II);
      Result[II - 1] := TPA2[I];
    end;
end;