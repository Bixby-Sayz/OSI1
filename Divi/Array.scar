{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                              Official SCAR Include
                                  Array Routines
--------------------------------------------------------------------------------
 * function InStrArrPos(S: string; Arr: TStrArray; var Pos: Integer; CaseSenstive: Boolean): Boolean;
     By: Wanted
 * function StrInStr(SubStr, S: string): Boolean;
     By: Wanted
 * function StrInStrMulti(SubStrs: TStrArray; S: string): Boolean;
     By: Wanted
 * function CheckTBoA(TBoA: TBoolArray): Integer;
     By: Wanted
 * procedure RemoveTPAFromATPA(var ATPA: T2DPointArray; Index: Integer);
     By: Wanted
 * function TBOutlineToTPA(TB: TBox): TPointArray;
     By: Wanted
 * function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
     By: Wanted
 * function LoadTextTPA(Text: string; Chars: Integer): TPointArray;
     By: Raymond
 * function FindTextTPAInTPA(TextTPA, SearchTPA: TPointArray; var X, Y: LongInt): Boolean;
     By: Wanted
 * procedure SortATPASize(var ATPA: T2DPointArray; BigFirst: Boolean);
     By: Wanted
 * procedure FilterPointsDist(var Points: TPointArray; MinDist, MaxDist, CX, CY: Extended);
     By: Wanted
 * procedure FilterPointsPie(var Points: TPointArray; SRad, ERad, SAng, EAng: Extended; CX, CY: Integer);
     By: Wanted                     
 * function FindColorCircleTol(var X, Y: Integer; Color, Tol, CX, CY, R: Integer): Boolean;
     By: Freddy
 * function FindColorCircleTolEx(var Points: TPointArray; Color, Tol, CX, CY, R: Integer): Boolean;
     By: Wanted
 * function PointsNotInTPA(TPA: TPointArray): TPointArray;
     By: Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function InStrArrPos(S: string; Arr: TStrArray; var Pos: Integer; CaseSenstive: Boolean): Boolean;
Contributors: Wanted
Description: Returns true if the string is in the array and returns position.
Date Created: October 10th, 2011. By Wanted
Last Modified: July 20th, 2012. By Freddy
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function InStrArrPos(S: string; Arr: TStrArray; var Pos: Integer; CaseSenstive: Boolean): Boolean;
var
  H, L: Integer;
  SS: string;
begin
  Result := True;
  H := High(Arr);
  L := Low(Arr);
  if (not (CaseSenstive)) then
  begin
    SS := LowerCase(S);
    for Pos := L to H do
      if (SS = LowerCase(Arr[Pos])) then
        Exit;
  end
  else
    for Pos := L to H do
      if (S = Arr[Pos]) then
        Exit;
  Result := False;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function StrInStr(SubStr, S: string): Boolean;
Contributors: Wanted
Description: Results true if a string is inside of another string.
Date Created: December 31st, 2011. By Wanted
Last Modified: December 31st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function StrInStr(SubStr, S: string): Boolean;
begin
  Result := (Pos(SubStr, S) > 0);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function StrInStrMulti(SubStrs: TStrArray; S: string): Boolean;
Contributors: Wanted
Description: Results true if any strings are inside a string.
Date Created: December 31st, 2011. By Wanted
Last Modified: July 20th, 2012. By Freddy
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function StrInStrMulti(SubStrs: TStrArray; S: string): Boolean;
var
  I, H: Integer;
begin
  H := High(SubStrs);
  Result := True;
  for I := 0 to H do
    if (StrInStr(SubStrs[I], S)) then
      Exit;
  Result := False;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function CheckTBoA(TBoA: TBoolArray): Integer;
Contributors: Wanted
Description: Results the amount of true booleans in boolean array.
Date Created: December 12th, 2011. By Wanted
Last Modified: July 20th, 2012. By Freddy
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function CheckTBoA(TBoA: TBoolArray): Integer;
var
  I, H: Integer;
begin
  Result := 0;
  H := High(TBoA);
  for I := 0 to H do
    if (TBoA[I]) then
      Inc(Result);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure RemoveTPAFromATPA(var ATPA: T2DPointArray; Index: Integer);
Contributors: Wanted
Description: Removes a TPA by index from an ATPA.
Date Created: November 14th, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure RemoveTPAFromATPA(var ATPA: T2DPointArray; Index: Integer);
var
  NewATPA: T2DPointArray;
  I, H, II: Integer;
begin
  if (Length(ATPA) < 1) then
    Exit;
  H := High(ATPA);
  if (Index > H) then
    Exit;
  SetLength(NewATPA, Length(ATPA) - 1);
  II := 0;
  for I := 0 to H do
    if (not (I = Index)) then
    begin
      NewATPA[II] := ATPA[I];
      Inc(II);
    end;
  ATPA := NewATPA;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBOutlineToTPA(TB: TBox): TPointArray;
Contributors: Wanted
Description: Turns the outline of a TBox into a TPA.
Date Created: October 22nd, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBOutlineToTPA(TB: TBox): TPointArray;
var
  I, II, Hi, Lo: Integer;
begin
  Result := [];
  SetLength(Result, (((TB.X2 - TB.X1) * 2) + ((TB.Y2 - TB.Y1) * 2)));
  if (Length(Result) < 1) then
    Exit;
  II := 0;
  for I := TB.X1 to TB.X2 do
  begin
    Result[II] := Point(I, TB.Y1);
    Inc(II);
  end;
  Lo := TB.Y1 + 1;
  Hi := TB.Y2 - 1;
  for I := Lo to Hi do
  begin
    Result[II] := Point(TB.X2, I);
    Inc(II);
  end;
  if (TB.Y1 <> TB.Y2) then
    for I := TB.X2 downto TB.X1 do
    begin
      Result[II] := Point(I, TB.Y2);
      Inc(II);
    end;
  for I := Hi downto Lo do
  begin
    Result[II] := Point(TB.X1, I);
    Inc(II);
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
Contributors: Wanted
Description: Turns the outline of multiple TBoxes into multi TPAs.
Date Created: October 22nd, 2011. By Wanted
Last Modified: October 22nd, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
var
  I, H: LongInt;
begin
  H := High(TBA);
  SetLength(Result, H + 1);
  for I := 0 to H do
    Result[I] := TBOutlineToTPA(TBA[I]);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function LoadTextTPA(Text: string; Chars: Integer): TPointArray;
Contributors: Raymond, Wanted, Freddy.
Description: Turns a line of text into an array of points.
Date Created: August 7th, 2011. By Anonymous
Last Modified: July 20th, 2012. By Freddy
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function LoadTextTPA(Text: string; Chars: Integer): TPointArray;
var      
  BmpText: TSCARBitmap; 
  Client: TSCARClient;
begin
  Result := [];
  if (Length(Text) < 1) then
    Exit;
  BmpText := CreateBitmapMaskFromText(Text, Chars);  
  Client := SetClient(TSCARBitmapClient.Create(BmpText));    
  try                              
    FindColorEx(Result, clWhite, 0, 0, BmpText.Width - 1, BmpText.Height - 1);
  finally      
    SetClient(Client).Free;
    BmpText.Free;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function FindTextTPAInTPA(TextTPA, SearchTPA: TPointArray; var X, Y: LongInt): Boolean;
Contributors: Wanted, Freddy.
Description: Checks a TPA to see if contains the a line of text using its TPA.
Date Created: October 20th, 2011. By Wanted
Last Modified: November 28th, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function FindTextTPAInTPA(Text: string; Chars: Integer; SearchTPA: TPointArray; var X, Y: LongInt): Boolean;
var
  TextTPA, TPA: TPointArray;
begin
  Result := False;
  TextTPA := LoadTextTPA(Text, Chars);
  try
    if (not (TPAInTPARelEx(TextTPA, SearchTPA, TPA))) then
      Exit;
  except
    Exit;
  end;
  X := TPA[0].X;
  Y := TPA[0].Y;
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure SortATPASize(var ATPA: T2DPointArray; BigFirst: Boolean);
Contributors: Wanted, Freddy.
Description: Sorts ATPAs based in their TPA lengths.
Date Created: October 22nd, 2011. By Wanted
Last Modified: October 23rd, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure SortATPASize(var ATPA: T2DPointArray; BigFirst: Boolean);
begin
  SortATPABySize(ATPA);
  if (BigFirst) then
    InvertATPA(ATPA);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure FilterPointsDist(var Points: TPointArray; MinDist, MaxDist, CX, CY: Extended);
Contributors: Wanted
Description: Removes all points not within distance.
Date Created: October 28th, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure FilterPointsDist(var Points: TPointArray; MinDist, MaxDist, CX, CY: Extended);
var
  H, L, I, HH: Integer;
  NewTPA: TPointArray;
  Dist: Extended;
begin
  H := High(Points);
  L := Low(Points);
  HH := 0;
  for I := L to H do
  begin
    Dist := DistanceEx(Points[I].X, Points[I].Y, CX, CY);
    if (Dist >= MinDist) then
      if (Dist <= MaxDist) then
      begin
        SetLength(NewTPA, HH + 1);
        NewTPA[HH] := Points[I];
        Inc(HH);
      end;
  end;
  Points := NewTPA;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure FilterPointsPie(var Points: TPointArray; SRad, ERad, SAng, EAng: Extended; CX, CY: Integer);
Contributors: Freddy, Wanted, Wizzup.
Description: Removes all points from a TPA except for a given slice.
Date Created: November 3rd, 2011. By Wanted
Last Modified: November 5th, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure FilterPointsPie(var Points: TPointArray; SRad, ERad, SAng, EAng: Extended; CX, CY: Integer);
var
  StartAngle, EndAngle, StartAngle2, EndAngle2: Extended;
  TPA, TPA2: TPointArray;
begin
  {$IFDEF RS2}
    StartAngle := SAng - 90;
    EndAngle := EAng - 90;
  {$ELSE}
    StartAngle := SAng;
    EndAngle := EAng;
  {$ENDIF}
  if (StartAngle < 0) then
  begin
    StartAngle2 := FixD(StartAngle);
    if (EndAngle < 0) then
    begin
      EndAngle2 := FixD(EndAngle);
      TPAExtractPie(Points, Point(CX, CY), SRad, ERad, Radians(StartAngle2), Radians(EndAngle2));
      Exit;
    end;
    StartAngle := 0;
    EndAngle2 := 360;
    TPA := Points;
    TPA2 := Points;
    TPAExtractPie(TPA, Point(CX, CY), SRad, ERad, Radians(StartAngle2), Radians(EndAngle2));
    TPAExtractPie(TPA2, Point(CX, CY), SRad, ERad, Radians(StartAngle), Radians(EndAngle));
    Points := CombineTPA(TPA, TPA2);
    Exit;
  end;
  TPAExtractPie(Points, Point(CX, CY), SRad, ERad, Radians(StartAngle), Radians(EndAngle));
end; 

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function FindColorCircleTol(var X, Y: Integer; Color, Tol, CX, CY, R: Integer): Boolean;
Contributors: Freddy
Description: Finds a color within circle.
Date Created: July 20th, 2012. By Freddy
Last Modified: July 20th, 2012. By Freddy
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function FindColorCircleTol(var X, Y: Integer; Color, Tol, CX, CY, R: Integer): Boolean;
begin
  Result := FindColorTPATol(X, Y, Color, TPAFromCircle(Point(CX, CY), R), Tol);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function FindColorCircleTolEx(var Points: TPointArray; Color, Tol, CX, CY, R: Integer): Boolean;
Contributors: Wanted, Freddy
Description: Finds colors within circle.
Date Created: October 28th, 2011. By Wanted
Last Modified: July 20th, 2012. By Freddy
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function FindColorCircleTolEx(var Points: TPointArray; Color, Tol, CX, CY, R: Integer): Boolean;
begin
  Result := FindColorTPATolEx(Points, Color, TPAFromCircle(Point(CX, CY), R), Tol);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function PointsNotInTPA(TPA: TPointArray): TPointArray;
Contributors: Wanted, Freddy.
Description: Finds empty points in TPA bounds.
Date Created: November 18th, 2011. By Wanted
Last Modified: January 15th, 2012. By Wanted. RS2 Build 697.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function PointsNotInTPA(TPA: TPointArray): TPointArray;
begin
  Result := TPAFromBox(TPABounds(TPA));
  TPAFilterPoints(Result, TPA);
end;