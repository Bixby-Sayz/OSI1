{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                              Official SCAR Include
                                  Box Routines
--------------------------------------------------------------------------------
 * procedure ClearBox(var bx: TBox);
 * procedure FixBox(var bx: TBox);
 * function BoxInBox(inner_bx, outer_bx: TBox): Boolean;
 * function ValidBox(bx: TBox): Boolean;
 * function SameBoxes(bx1, bx2: TBox): Boolean;
 * function BoxCenter(bx: TBox): TPoint;
 * procedure ExpandBox(var bx: TBox; eSize: Integer);
 * procedure ShrinkBox(var bx: TBox; sSize: Integer);
 * procedure ResizeBox(var bx: TBox; pixels, method: Integer);
 * procedure OffsetBox(var bx: TBox; xOffset, yOffset: Integer);
 * procedure BoxDimensions(bx: TBox; var w, h: Integer);
 * procedure BoxCentralization(var inner_bx: TBox; outer_bx: TBox; method: Integer);
 * function TBABounds(TBA: TBoxArray): TBox;
 * function TBASame(TBA1, TBA2: TBoxArray): Boolean;
 * procedure TBAInsert(var TBA: TBoxArray; index: Integer; bx: TBox);
 * procedure TBAUnique(var TBA: TBoxArray);
 * function TBADelete(var TBA: TBoxArray; x: Integer): Boolean;
 * procedure TBARandomize(var TBA: TBoxArray);
 * procedure TBAClear(var TBA: TBoxArray; IDs: TIntArray);
 * function TBAContains(TBA: TBoxArray; bx: TBox): Boolean;
 * function TBAPositions(TBA: TBoxArray; bx: TBox): TIntArray;
 * function TBAAllValuesSame(TBA: TBoxArray): Boolean;
 * function TBAAllValuesUnique(TBA: TBoxArray): Boolean;
 * function TBOutlineToTPA(TB: TBox): TPointArray;
 * function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure ClearBox(var bx: TBox);
Contributors: Janilabo
Description: Clears the bx..Basically, bx is replaced with an empty TBox (tmp).
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure ClearBox(var bx: TBox);
var
  tmp: TBox;
begin
  bx := tmp;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure FixBox(var bx: TBox);
Contributors: Janilabo
Description: Fixes the bx. Swaps incorrectly set values (X1/Y1 > X2/Y2).
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.
Example: (200*, 100, 100*, 200) => (100, 100, 200, 200)       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure FixBox(var bx: TBox);
begin
  if (bx.X1 > bx.X2) then
    Swap(bx.X1, bx.X2);
  if (bx.Y1 > bx.Y2) then
    Swap(bx.Y1, bx.Y2);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function BoxInBox(inner_bx, outer_bx: TBox): Boolean;
Contributors: Janilabo
Description: Returns true if inner_bx is inside outer_bx.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function BoxInBox(inner_bx, outer_bx: TBox): Boolean;
begin
  if ((inner_bx.X1 <= inner_bx.X2) and (inner_bx.Y1 <= inner_bx.Y2) and (outer_bx.X1 <= outer_bx.X2) and (outer_bx.Y1 <= outer_bx.Y2)) then
    Result := ((inner_bx.X1 >= outer_bx.X1) and (inner_bx.X1 <= outer_bx.X2) and (inner_bx.X2 >= outer_bx.X1) and (inner_bx.X2 <= outer_bx.X2) and
               (inner_bx.Y1 >= outer_bx.Y1) and (inner_bx.Y1 <= outer_bx.Y2) and (inner_bx.Y2 >= outer_bx.Y1) and (inner_bx.Y2 <= outer_bx.Y2));
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function ValidBox(bx: TBox): Boolean;
Contributors: Janilabo
Description: Returns true if bx is valid (X1 <= X2 AND Y1 <= Y2).
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function ValidBox(bx: TBox): Boolean;
begin
  Result := ((bx.x1 <= bx.X2) and (bx.y1 <= bx.Y2));
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function SameBoxes(bx1, bx2: TBox): Boolean;
Contributors: Janilabo
Description: Returns true if bx1 and bx2 are identical.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function SameBoxes(bx1, bx2: TBox): Boolean;
begin
  Result := ((bx1.X1 = bx2.X1) and (bx1.Y1 = bx2.Y1) and
             (bx1.X2 = bx2.X2) and (bx1.Y2 = bx2.Y2));
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function BoxCenter(bx: TBox): TPoint;
Contributors: Janilabo
Description: Returns the center point of bx.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function BoxCenter(bx: TBox): TPoint;
begin
  if ((bx.X1 <= bx.X2) and (bx.Y1 <= bx.Y2)) then
    Result := Point(Round(bx.X1 + ((bx.X2 - bx.X1) / 2)), Round(bx.Y1 + ((bx.Y2 - bx.Y1) / 2)));
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure ExpandBox(var bx: TBox; eSize: Integer);
Contributors: Janilabo
Description: Expands bx to all directions using eSize as the pixel amount to expand.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure ExpandBox(var bx: TBox; eSize: Integer);
begin
  if (eSize < 1) then
    Exit;
  bx.X1 := (bx.X1 - eSize);
  bx.Y1 := (bx.Y1 - eSize);
  bx.X2 := (bx.X2 + eSize);
  bx.Y2 := (bx.Y2 + eSize);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure ShrinkBox(var bx: TBox; sSize: Integer);
Contributors: Janilabo
Description: Shrinks bx from all directions using sSize as the pixel amount to shrink.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure ShrinkBox(var bx: TBox; sSize: Integer);
begin
  if (sSize < 1) then
    Exit;
  bx.X1 := (bx.X1 + sSize);
  bx.Y1 := (bx.Y1 + sSize);
  bx.X2 := (bx.X2 - sSize);
  bx.Y2 := (bx.Y2 - sSize);
end; 

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure ResizeBox(var bx: TBox; pixels, method: Integer);
Contributors: Janilabo
Description: Resizes bx by pixels as the amount.. Contains 11 methods for every direction.
Directions (methods) are listed and commented below.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure ResizeBox(var bx: TBox; pixels, method: Integer);
begin 
  if (pixels = 0) then Exit;
  case method of
    0: bx := Box((bx.X1 - pixels), (bx.Y1 - pixels), (bx.X2 + pixels), (bx.Y2 + pixels)); // ALL AREAS 
    1: bx := Box((bx.X1 - pixels), bx.Y1, (bx.X2 + pixels), bx.Y2); // WIDTH
    2: bx := Box(bx.X1, (bx.Y1 - pixels), bx.X2, (bx.Y2 + pixels)); // HEIGHT
    3: bx := Box(bx.X1, (bx.Y1 - pixels), bx.X2, bx.Y2); // UP
    4: bx := Box(bx.X1, bx.Y1, bx.X2, (bx.Y2 + pixels)); // DOWN
    5: bx := Box((bx.X1 - pixels), bx.Y1, bx.X2, bx.Y2); // LEFT 
    6: bx := Box(bx.X1, bx.Y1, (bx.X2 + pixels), bx.Y2); // RIGHT
    7: bx := Box((bx.X1 - pixels), (bx.Y1 - pixels), bx.X2, bx.Y2); // TOP-LEFT 
    8: bx := Box(bx.X1, (bx.Y1 - pixels), (bx.X2 + pixels), bx.Y2); // TOP-RIGHT
    9: bx := Box((bx.X1 - pixels), bx.X1, bx.X2, (bx.Y2 + pixels)); // BOTTOM-LEFT
    10: bx := Box(bx.X1, bx.Y1, (bx.X2 + pixels), (bx.Y2 + pixels)); // BOTTOM-RIGHT 
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure OffsetBox(var bx: TBox; xOffset, yOffset: Integer);
Contributors: Janilabo
Description: Offsets bx using xOffset, yOffset.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure OffsetBox(var bx: TBox; xOffset, yOffset: Integer);
begin
  if ((xOffset and yOffset) = 0) then Exit;
  bx.X1 := (bx.X1 + xOffset);
  bx.Y1 := (bx.Y1 + yOffset);
  bx.X2 := (bx.X2 + xOffset);
  bx.Y2 := (bx.Y2 + yOffset);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure BoxDimensions(bx: TBox; var w, h: Integer);
Contributors: Janilabo
Description: Stores bx dimensions to w (width) and h (height) variables.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure BoxDimensions(bx: TBox; var w, h: Integer);
begin
  w := ((bx.X2 - bx.X1) + 1);
  h := ((bx.Y2 - bx.Y1) + 1);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure BoxCentralization(var inner_bx: TBox; outer_bx: TBox; method: Integer);
Contributors: Janilabo
Description: Sets inner bx to center of outer bx. Contains 3 methods.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
Explanation: Methods: muWidthHeight = center width & heightwise, 
                      muWidth = center widthwise, 
                      muHeight = center heightwise.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure BoxCentralization(var inner_bx: TBox; outer_bx: TBox; method: Integer);
var
  i_w, i_h: Integer;
  c_pt, d_pt: TPoint;
begin
  BoxDimensions(inner_bx, i_w, i_h);
  c_pt := BoxCenter(outer_bx);
  d_pt := Point((c_pt.X - (i_w div 2)), (c_pt.Y - (i_h div 2)));
  case method of
    muWidthHeight: OffsetBox(inner_bx, (d_pt.Y - inner_bx.Y1), (d_pt.X - inner_bx.X1));
    muWidth: OffsetBox(inner_bx, (d_pt.X - inner_bx.X1), 0);
    muHeight: OffsetBox(inner_bx, 0, (d_pt.Y - inner_bx.Y1));
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBABounds(TBA: TBoxArray): TBox;
Contributors: Janilabo
Description: Returns the bounds of TBA.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBABounds(TBA: TBoxArray): TBox;
var
  h, i: Integer;
begin
  h := High(TBA);
  if (h < 0) then
    Exit;
  Result := TBA[0];
  for i := 0 to h do
  begin
    if (Result.X1 > TBA[i].X1) then
      Result.X1 := TBA[i].X1;
    if (Result.Y1 > TBA[i].Y1) then
      Result.Y1 := TBA[i].Y1;
    if (Result.X2 < TBA[i].X2) then
      Result.X2 := TBA[i].X2;
    if (Result.Y2 < TBA[i].Y2) then
      Result.Y2 := TBA[i].Y2;
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBASame(TBA1, TBA2: TBoxArray): Boolean;
Contributors: Janilabo
Description: Returns true if TBA1 and TBA2 are identical.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBASame(TBA1, TBA2: TBoxArray): Boolean;
var
  h, i: Integer;
begin
  h := High(TBA1);
  if ((h < 0) or (h <> High(TBA2))) then
    Exit;
  for i := 0 to h do
    if ((TBA1[i].X1 <> TBA2[i].X1) or (TBA1[i].Y1 <> TBA2[i].Y1) or (TBA1[i].X2 <> TBA2[i].X2) or (TBA1[i].Y2 <> TBA2[i].Y2)) then
      Exit;
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure TBAInsert(var TBA: TBoxArray; index: Integer; bx: TBox);
Contributors: Janilabo
Description: Inserts bx to index position of TBA.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure TBAInsert(var TBA: TBoxArray; index: Integer; bx: TBox);
var
  i, l: Integer;
begin
  l := Length(TBA);
  SetLength(TBA, (l + 1));    
  if (index < 0) then
    index := 0;
  if (index > l) then
    index := l;
  if (l > index) then
    for i := (l - 1) downto index do
      TBA[(i + 1)] := TBA[i];
  TBA[index] := bx; 
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure TBAUnique(var TBA: TBoxArray);
Contributors: Janilabo
Description: Removes any and all duplicates from TBA.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure TBAUnique(var TBA: TBoxArray);
var
  h, i2, i, d: Integer; 
begin
  h := High(TBA);   
  if (h < 1) then
    Exit;         
  for i := (h - d) downto 1 do
    for i2 := (i - 1) downto 0 do
      if (TBA[i] = TBA[i2]) then
      begin
        Delete(TBA, i, 1);
        Inc(d);
        Break;  
      end;  
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBADelete(var TBA: TBoxArray; x: Integer): Boolean;
Contributors: Janilabo, LordJashin
Description: Deletes TBA item by x as the index position. Returns true with success.
Date Created: September 30th, 2012. By Janilabo.
Last Modified: October 5th, 2012. By Janilabo.
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBADelete(var TBA: TBoxArray; x: Integer): Boolean;
begin
  Result := ((x < (High(TBA) + 1)) and (x > -1));
  if Result then
    Delete(TBA, x, 1);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure TBARandomize(var TBA: TBoxArray);
Contributors: Janilabo
Description: Randomizes which boxes are at what index in the TBA              
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure TBARandomize(var TBA: TBoxArray);
var
  i, h: integer;
begin
  h := High(TBA);
  for i := 0 to h do
    Swap(TBA[Random(h + 1)], TBA[Random(h + 1)]);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
procedure TBAClear(var TBA: TBoxArray; IDs: TIntArray);
Contributors: Janilabo
Description: Clears TBA boxes at the indexs (IDs).                 
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

procedure TBAClear(var TBA: TBoxArray; IDs: TIntArray);
var
  i, h, h2: Integer;
  tmp: TBox;
begin
  h := High(IDs);
  h2 := High(TBA);
  for i := 0 to h do
    if InRange(IDs[i], 0, h2) then
      TBA[IDs[i]] := tmp;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBAContains(TBA: TBoxArray; bx: TBox): Boolean;
Contributors: Janilabo
Description: Returns true if TBA contains bx.                 
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBAContains(TBA: TBoxArray; bx: TBox): Boolean;
var
  i, h: Integer;
begin
  h := High(TBA);
  for i := 0 to h do
    if ((bx.x1 = TBA[i].x1) and (bx.y1 = TBA[i].y1) and
        (bx.x2 = TBA[i].x2) and (bx.y2 = TBA[i].y2)) then
    begin
      Result := True;
      Exit;
    end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBAPositions(TBA: TBoxArray; bx: TBox): TIntArray;
Contributors: Janilabo
Description: Returns all the positions in TBA where bx is found/matched.                 
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBAPositions(TBA: TBoxArray; bx: TBox): TIntArray;
var
  i, h, rC: Integer;
begin
  h := High(TBA);
  SetLength(Result, (h + 1));
  for i := 0 to h do
    if ((bx.x1 = TBA[i].x1) and (bx.y1 = TBA[i].y1) and
        (bx.x2 = TBA[i].x2) and (bx.y2 = TBA[i].y2)) then
    begin
      Result[rC] := i;
      Inc(rC);
    end;
  SetLength(Result, rC);
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBAAllValuesSame(TBA: TBoxArray): Boolean;
Contributors: Janilabo
Description: Returns true if all TBA items are identical.                 
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBAAllValuesSame(TBA: TBoxArray): Boolean;
var
  h, i: Integer;
begin
  h := High(TBA);
  if (h < 1) then
  begin
    Result := (h = 0);
    Exit;
  end;
  for i := 1 to h do
    if (TBA[i] <> TBA[0]) then
      Exit;
  Result := True;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBAAllValuesUnique(TBA: TBoxArray): Boolean;
Contributors: Janilabo
Description: Returns true if all TBA values are unique.                 
Date Created: September 30th, 2012. By Janilabo.
Last Modified: September 30th, 2012. By Janilabo.       
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBAAllValuesUnique(TBA: TBoxArray): Boolean;
var
  h, i, i2: Integer;
begin
  h := High(TBA);
  if (h < 1) then
  begin
    Result := (h = 0);
    Exit;
  end;
  for i := 0 to (h - 1) do
    for i2 := (i + 1) to h do
      if (i <> i2) then
      begin
        Result := (TBA[i] <> TBA[i2]);
        if not Result then
          Exit;
      end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBOutlineToTPA(TB: TBox): TPointArray;
Contributors: Wanted
Description: Turns the outline of a TBox into a TPA.
Date Created: October 22nd, 2011. By Wanted
Last Modified: November 21st, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBOutlineToTPA(TB: TBox): TPointArray;
var
  I, II, Hi, Lo: Integer;
begin
  Result := [];
  SetLength(Result, (((TB.X2 - TB.X1) * 2) + ((TB.Y2 - TB.Y1) * 2)));
  if (Length(Result) < 1) then
    Exit;
  II := 0;
  for I := TB.X1 to TB.X2 do
  begin
    Result[II] := Point(I, TB.Y1);
    Inc(II);
  end;
  Lo := TB.Y1 + 1;
  Hi := TB.Y2 - 1;
  for I := Lo to Hi do
  begin
    Result[II] := Point(TB.X2, I);
    Inc(II);
  end;
  if (TB.Y1 <> TB.Y2) then
    for I := TB.X2 downto TB.X1 do
    begin
      Result[II] := Point(I, TB.Y2);
      Inc(II);
    end;
  for I := Hi downto Lo do
  begin
    Result[II] := Point(TB.X1, I);
    Inc(II);
  end;
end;

{=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
Contributors: Wanted
Description: Turns the outline of multiple TBoxes into multi TPAs.
Date Created: October 22nd, 2011. By Wanted
Last Modified: October 22nd, 2011. By Wanted
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=}

function TBAOutlineToATPA(TBA: TBoxArray): T2DPointArray;
var
  I, H: LongInt;
begin
  H := High(TBA);
  SetLength(Result, H + 1);
  for I := 0 to H do
    Result[I] := TBOutlineToTPA(TBA[I]);
end;

